/*
状态压缩DP经典题
蒙德里安的梦想 Acwing291
好难救命！SOS！
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;
typedef long long LL;
//数据范围是1-11
const int N = 12,M = 1<<N;
int n,m;
//方案数量比较大，所以用long long来存放
//第一维表示列，第二维表示状态
//f[i][j]:表示前i-1列的方案已经确定，从i-1列伸出并且第i列状态是j的所有方案
LL f[N][M];

//二维数组，记录合法的状态
vector<int>state[M]; 

//第i-2列伸到i-1列的状态为k，是否能成功转移到第i-1列 伸到i的状态为j
//存储每种状态是否有奇数个连续的0，如果奇数个0时无效的。
bool st[M]; 

int main(){
    
    while(cin >> n >> m, n|| m){ 
        
        //第一个部分：预处理1
        //对于每种状态，先预处理每列不能有奇数个连续的0.
    
        for(int i=0;i< (1 << n);i++){

            //记录一列中0的个数
            int cnt = 0; 

            //能否进行从i-2列伸到i-1列的状态为k 转到 从i-1列伸到i列的状态为j
            bool is_valid = true;

            //遍历这一列，从上到下
            for(int j = 0;j<n;j++){

                //这句位运算：表示i的（i在这里时状态）的二进制数的第j位
                //如果这个位数时1 就进入判断签名连续0的个数
                if((i >> j) &1){ 
                    //如果防止的小方块的连续空白格子数量为奇数
                    if(cnt & 1){
                        is_valid = false;
                        break;
                    }
                    //既然该位是1，并且前面不是奇数个0，计数器没啥用啦。
                    cnt = 0;
                
                //否则如果这个位数上是0，那计数器就有统计的意义了
                }else cnt ++;
            }
            if(cnt &1) is_valid = false; // 连续0个数是奇数
            st[i] = is_valid; // 状态i是否有奇数个连续0的情况，输入到st数组中
        }
        
        //第二部分的预处理
        //上面筛掉了第一种不合法的情况：连续0的判断
        //下面进行进一步判断：i-2列伸出去的 和 第i-1列伸出去是否冲突
        //即是否在同一行重叠的情况

        //对于第i列的所有状态
        for(int i=0;i<1 << n;i++)
        {
            //清空上次操作遗留的状态，防止影响本次状态
            state[i].clear(); // 因为是连续读入的

            //对于第i-1列的所有状态
            for(int j=0;j<1 << n;j++)
                //c从第i-2列伸出来的和 第i-1列伸出来的不冲突
                //st[i | j]
                //i|j 表示 第i-1 列到底有多少个1，因为第i-1列多少个1
                //是由第i-2 列伸出去的和第i-1列伸出去的 共同决定，所以是一个或关系
                //所以这里表示，保证i-1列必须是不能是同一行的情况下  并且 第i-1列这种状态是合法的
                if((i&j) ==0 && st[i | j]) 
                    state[i].push_back(j);
                    //表示第i列真正可行的状态，

        }
    //第三个部分 dp
    //初始化为0，因为是连续读入
    memset(f,0,sizeof f);
    //第0列只有竖着摆放这一种状态
    f[0][0] = 1;
    for(int i=1;i<=m;i++) // 遍历每一列
        for(int j=0;j<1 << n;j++) // 2^n状态
            for(auto k :state[j]) // i-1行的状态是满足的，如果可行就转移
                f[i][j] += f[i-1][k]; //当前列的方案数就等于之前i-1列所有状态k的累加
    
    //m-1列都处理完成，并且第m-1列没有伸出来的所有方案书
    //也就是整个棋盘处理完的方案数
    cout << f[m][0]<< endl;
    }    

    return 0;
}